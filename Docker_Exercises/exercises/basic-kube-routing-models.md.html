<html>
<head>
    <title>basic-kube-routing-models.md</title>
    <link href='https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css' rel='stylesheet' integrity='sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u' crossorigin='anonymous'>
    <link href="../app.css" rel="stylesheet" >
</head>
<body>
    <nav class="navbar navbar-default">
    <div class="container">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header">
        <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../index.html"><img class="logo" src="https://www.docker.com/sites/all/themes/docker/assets/images/brand-full.svg" alt="Docker" title="Docker"/></a>
        </div>
    </div><!-- /.container-fluid -->
    </nav>
    <div class="container">
    <div class="row">
        <div class="content">
            <h1 id="basic-kubernetes-routing-models">Basic Kubernetes Routing Models</h1>
<p>By the end of this exercise, you should be able to:</p>
<ul>
<li>Route traffic to a kube deployment using the correct tool in each of the following scenarios:<ul>
<li>Cluster-internal traffic to a stateless deployment</li>
<li>Cluster-internal traffic to a stateful deployment</li>
<li>Ingress traffic to a stateless deployment</li>
</ul>
</li>
</ul>
<h2 id="routing-cluster-internal-traffic">Routing Cluster-Internal Traffic</h2>
<p>By <em>cluster-internal traffic</em>, we mean traffic from originating from a pod running on your cluster, sending a request to another pod running on the same cluster. We need to consider two cases: </p>
<ul>
<li><strong>Stateless deployments</strong>: can be load balanced across freely. A containerized API would be a common example.</li>
<li><strong>Stateful deployments</strong>: we may need to make explicit and consistent decisions about what container we send a request to. A containerized database using simple local storage is a common example.</li>
</ul>
<h3 id="routing-to-stateless-deployments">Routing to Stateless Deployments</h3>
<p>Routing to stateless deployments internal to a cluster relies on use of a <code>ClusterIP</code> service, which will provide a stable networking endpoint for a collection of containers, similar in usage (though not implementation) to Swarm&#39;s VIPs.</p>
<ol>
<li><p>Declare a deployment to route traffic to by navigating on UCP <strong>Kubernetes -&gt; Create</strong>, pasting in the following yaml and clicking <strong>Create</strong>:</p>
<pre><code class="lang-yaml">apiVersion: apps/v1
kind: Deployment
metadata:
  name: destination
  namespace: default
spec:
  replicas: 3
  selector:
    matchLabels:
      app: dest
  template:
    metadata:
      labels:
        app: dest
    spec:
      containers:
      - name: who
        image: training/whoami:latest
</code></pre>
</li>
<li><p>Declare a <code>ClusterIP</code> service to route traffic to your <code>destination</code> deployment internally:</p>
<pre><code class="lang-yaml">apiVersion: v1
kind: Service
metadata:
  name: destination-entrypoint
  namespace: default
spec:
  selector:
    app: dest
  ports:
  - port: 8080
    targetPort: 8000
</code></pre>
<p>This service will route traffic sent to port 8080 on the IP generated by this service, to port 8000 in pods which match the <code>app: dest</code> label selector.</p>
</li>
<li><p>Declare another deployment we&#39;ll use to send traffic to the first:</p>
<pre><code class="lang-yaml">apiVersion: apps/v1
kind: Deployment
metadata:
  name: origin
  namespace: default
spec:
  replicas: 1
  selector:
    matchLabels:
      app: orig
  template:
    metadata:
      labels:
        app: orig
    spec:
      containers:
      - name: probe
        image: nicolaka/netshoot:latest
        command: [&quot;sleep&quot;]
        args: [&quot;1000000&quot;]
</code></pre>
</li>
<li><p>Next we&#39;d like to open a terminal inside the <code>netshoot</code> container of our <code>origin</code> pod:</p>
<ul>
<li>Navigate <strong>Kubernetes -&gt; Pods -&gt; origin</strong></li>
<li>Click on the <strong>&gt;_</strong> icon in the top right</li>
<li>Enter <code>bash</code> in the box and click <strong>Run</strong></li>
</ul>
</li>
<li><p>At the terminal you just opened in UCP, use <code>nslookup</code> to see what <code>destination-entrypoint</code> resolves as:</p>
<pre><code class="lang-bash">bash-5.0# nslookup destination-entrypoint

Server:         10.96.0.10                                                                                               
Address:        10.96.0.10#53                                                                                            

Name:   destination-entrypoint.default.svc.cluster.local                                                                 
Address: 10.96.231.233 
</code></pre>
<p>The <code>Address</code> on the last line is the cluster IP chosen for this service. Traffic to port 8080 (which we defined in the yaml for our service above) at this IP will get randomly load balanced across pods matching the label selector provided.</p>
</li>
<li><p>In the same terminal, try <code>curl</code>ing the service name and port:</p>
<pre><code class="lang-bash">bash-5.0# curl destination-entrypoint:8080                                                                               
I&#39;m destination-6747cb6454-99xzs                                                                                         
bash-5.0# curl destination-entrypoint:8080                                                                               
I&#39;m destination-6747cb6454-7h6jg                                                                                         
bash-5.0# curl destination-entrypoint:8080                                                                               
I&#39;m destination-6747cb6454-7h6jg                                                                                         
bash-5.0# curl destination-entrypoint:8080                                                                               
I&#39;m destination-6747cb6454-7h6jg                                                                                         
bash-5.0# curl destination-entrypoint:8080                                                                               
I&#39;m destination-6747cb6454-sdpgr 
</code></pre>
<p>Unlike swarm, a kube <code>ClusterIP</code> routes traffic randomly to pods it serves, rather than round robin.</p>
</li>
<li><p>Delete your &#39;destination-entrypoint&#39; service:</p>
<ul>
<li>Navigate <strong>Kubernetes -&gt; Services</strong></li>
<li>Check the checkbox beside <strong>destination-entrypoint</strong></li>
<li>Click <strong>Actions -&gt; Remove</strong></li>
</ul>
</li>
</ol>
<h3 id="routing-to-stateful-deployments">Routing to Stateful Deployments</h3>
<p>If our destination deployment is stateful, the random load balancing provided by the ClusterIP service above isn&#39;t appropriate; we want to be able to discover the IPs of the pods underlying a deployment directly, and make our own routing decisions from there.</p>
<ol>
<li><p>Create a new <code>destination-entrypoint</code> service, this time as a <em>headless ClusterIP</em>:</p>
<pre><code class="lang-yaml">apiVersion: v1
kind: Service
metadata:
  name: destination-entrypoint
  namespace: default
spec:
  clusterIP: None
  selector:
    app: dest
</code></pre>
<p>Note the <code>clusterIP: None</code> line - that&#39;s what makes this service headless.</p>
</li>
<li><p>Open a bash terminal inside the <code>netshoot</code> container of our <code>origin</code> pod like you did above, and try <code>nslookup</code> on <code>destination-entrypoint</code> again:</p>
<pre><code class="lang-bash">bash-5.0# nslookup destination-entrypoint     

Server:         10.96.0.10                                                                                               
Address:        10.96.0.10#53                                                                                            

Name:   destination-entrypoint.default.svc.cluster.local                                                                 
Address: 192.168.162.197                                                                                                 
Name:   destination-entrypoint.default.svc.cluster.local                                                                 
Address: 192.168.197.132                                                                                                 
Name:   destination-entrypoint.default.svc.cluster.local                                                                 
Address: 192.168.107.70
</code></pre>
<p>This time, the IPs of all the pods matched by your service&#39;s label selector are returned. Try <code>curl</code>ing a few of these on port 8000 to confirm the routing works. The headless clusterIP effectively lets us choose which backend pod we want to route to, and provides us a convenient way to discover what the IPs of all the currently ready backend pods are.</p>
</li>
<li><p>Delete your <code>destination-entrypoint</code> service as above.</p>
</li>
</ol>
<h2 id="routing-ingress-traffic">Routing Ingress Traffic</h2>
<p>In the case that we want to allow traffic in to a deployment from the outside world, we need to route traffic from a port in the host&#39;s network namespace onto a port in the pod&#39;s network namespace; we can accomplish this through a NodePort service.</p>
<h3 id="ingress-traffic-to-stateless-deployments">Ingress Traffic to Stateless deployments</h3>
<p>In the case of stateless deployments, we want to build off of the ClusterIP service that we saw in the first section above. To do so, we&#39;ll create a NodePort service which will forward traffic from a random port on every host in our cluster to a ClusterIP service it automatically creates for us.</p>
<ol>
<li><p>Re-create your <code>destination-entrypoint</code> service as a NodePort service:</p>
<pre><code class="lang-yaml">apiVersion: v1
kind: Service
metadata:
  name: destination-entrypoint
  namespace: default
spec:
  type: NodePort
  selector:
    app: dest
  ports:
  - port: 8080
    targetPort: 8000
</code></pre>
<p>Key values here being the <code>type: NodePort</code> to declare this as the desired service type, and the <code>port</code> and <code>targetPort</code> keys which have the same meaning as the ClusterIP service we created in the first exercise above.</p>
</li>
<li><p>Navigate <strong>Kubernetes -&gt; Services -&gt; destination-entrypoint</strong>, scroll to the bottom, and find the <strong>Node Port</strong> entry in the table (should be something in the 32768-35535 range). This is the port your deployment pods are reachable at, on any IP in your kube cluster. Try <code>curl</code>ing <ucp-manager-0>:<node port> from your <code>infra</code> node to confirm the traffic is routed as expected.</p>
</li>
<li><p>Delete your origin, destination, and destination-entrypoint deployments and services as above.</p>
</li>
</ol>
<h2 id="conclusion">Conclusion</h2>
<p>In this exercise, you set up basic examples of cluster routing intended for use with stateful and stateless deployments receiving traffic from inside or outside your cluster. Understanding how traffic is meant to be routed to your deployments is a key thing to find out from your developers as images move from development into production; ask them for clear answers on whether their containers are stateful or stateless, and whether they expect traffic from inside the cluster or from the external network, and then follow the examples above to successfully configure traffic routing as designed. One configuration that is not currently easily supported on Kubernetes is routing traffic to specific (ie stateful) pods from outside the cluster in a way analogous to Swarm&#39;s <code>mode=host</code> binding; nevertheless, we&#39;ll see in a later exercise some more sophisticated kube routing technology that will solve this problem in some cases. </p>

        </div>        
    </div>
    <div class="row">
        <ul class="mt-article-pagination" style="display:block;">
        </ul>
    </div>
</div>
    <div class="footer"></div>
</body>